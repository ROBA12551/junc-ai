<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Signal Monitor - Professional Trading</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --bg-primary: #0a0e27;
            --bg-secondary: #0f1429;
            --bg-tertiary: #1a1f3a;
            --accent: #00d9ff;
            --accent-light: #4dc9ff;
            --success: #00ff88;
            --danger: #ff3366;
            --warning: #ffaa00;
            --text-primary: #ffffff;
            --text-secondary: #a0a0b0;
            --border: rgba(0, 217, 255, 0.15);
            --grid-bg: rgba(0, 217, 255, 0.05);
        }
        
        body {
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }
        
        .grid-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 217, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 217, 255, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: 0;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 380px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            position: relative;
            z-index: 1;
        }
        
        /* Header */
        .header {
            grid-column: 1 / -1;
            background: rgba(10, 14, 39, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border);
            padding: 0 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 30px;
        }
        
        .logo {
            font-size: 16px;
            font-weight: 700;
            letter-spacing: 3px;
            background: linear-gradient(135deg, var(--accent), var(--accent-light));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            padding: 6px 12px;
            background: rgba(0, 217, 255, 0.1);
            border: 1px solid var(--border);
            border-radius: 3px;
        }
        
        .status-dot {
            width: 6px;
            height: 6px;
            background: var(--success);
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
        
        .time-display {
            font-size: 11px;
            color: var(--text-secondary);
            min-width: 100px;
        }
        
        /* Main Content */
        .main-content {
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 15px;
            overflow-y: auto;
        }
        
        /* Search Section */
        .search-section {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .search-box {
            flex: 1;
            display: flex;
            gap: 8px;
        }
        
        .search-box input {
            flex: 1;
            padding: 10px 12px;
            background: var(--grid-bg);
            border: 1px solid var(--border);
            border-radius: 3px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 11px;
            transition: all 0.3s;
        }
        
        .search-box input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 217, 255, 0.08);
            box-shadow: 0 0 15px rgba(0, 217, 255, 0.1);
        }
        
        .search-btn {
            padding: 10px 16px;
            background: var(--accent);
            color: var(--bg-primary);
            border: none;
            border-radius: 3px;
            font-weight: bold;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .search-btn:hover {
            background: var(--accent-light);
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(0, 217, 255, 0.3);
        }
        
        /* Symbol Grid */
        .symbols-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(75px, 1fr));
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .symbol-chip {
            padding: 8px 10px;
            background: var(--grid-bg);
            border: 1px solid var(--border);
            border-radius: 3px;
            color: var(--accent);
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
            font-family: inherit;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-align: center;
        }
        
        .symbol-chip:hover {
            border-color: var(--accent);
            background: rgba(0, 217, 255, 0.15);
            transform: translateY(-2px);
        }
        
        .symbol-chip.active {
            background: var(--accent);
            color: var(--bg-primary);
            border-color: var(--accent);
        }
        
        /* Signals Container */
        .signals-wrapper {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .signal-card {
            background: rgba(26, 31, 58, 0.7);
            border: 1px solid var(--border);
            border-left: 3px solid var(--text-secondary);
            border-radius: 3px;
            padding: 12px 14px;
            cursor: pointer;
            transition: all 0.2s;
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-15px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .signal-card:hover {
            border-color: var(--accent);
            background: rgba(0, 217, 255, 0.1);
            transform: translateX(3px);
        }
        
        .signal-card.buy {
            border-left-color: var(--success);
        }
        
        .signal-card.buy:hover {
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.15);
        }
        
        .signal-card.sell {
            border-left-color: var(--danger);
        }
        
        .signal-card.sell:hover {
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.15);
        }
        
        .signal-card.neutral {
            border-left-color: var(--warning);
        }
        
        .signal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .signal-symbol {
            font-size: 13px;
            font-weight: bold;
            color: var(--accent);
            letter-spacing: 1px;
        }
        
        .signal-badge {
            padding: 2px 8px;
            border-radius: 2px;
            font-size: 9px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .signal-badge.buy {
            background: rgba(0, 255, 136, 0.2);
            color: var(--success);
        }
        
        .signal-badge.sell {
            background: rgba(255, 51, 102, 0.2);
            color: var(--danger);
        }
        
        .signal-badge.neutral {
            background: rgba(255, 170, 0, 0.2);
            color: var(--warning);
        }
        
        .signal-metrics {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            font-size: 10px;
        }
        
        .metric {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        
        .metric-label {
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 8px;
        }
        
        .metric-value {
            color: var(--accent);
            font-weight: bold;
        }
        
        .strength-meter {
            height: 2px;
            background: rgba(0, 217, 255, 0.2);
            border-radius: 1px;
            margin-top: 6px;
            overflow: hidden;
        }
        
        .strength-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent-light));
            transition: width 0.3s;
        }
        
        /* Right Panel - Chat */
        .chat-panel {
            background: rgba(26, 31, 58, 0.9);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 15px;
            gap: 12px;
        }
        
        .chat-header {
            font-size: 11px;
            font-weight: bold;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }
        
        .chat-display {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .chat-msg {
            padding: 8px 10px;
            border-radius: 3px;
            font-size: 9px;
            line-height: 1.5;
            word-break: break-word;
            animation: fadeIn 0.3s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .chat-msg.bot {
            background: rgba(0, 217, 255, 0.1);
            border-left: 2px solid var(--accent);
            color: var(--accent);
        }
        
        .chat-msg.user {
            background: rgba(0, 255, 136, 0.1);
            border-left: 2px solid var(--success);
            color: var(--success);
            align-self: flex-end;
            max-width: 95%;
        }
        
        .chat-input-box {
            display: flex;
            gap: 8px;
            padding-top: 10px;
            border-top: 1px solid var(--border);
        }
        
        .chat-input-box input {
            flex: 1;
            padding: 8px 10px;
            background: var(--grid-bg);
            border: 1px solid var(--border);
            border-radius: 3px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 9px;
            transition: all 0.2s;
        }
        
        .chat-input-box input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 217, 255, 0.08);
        }
        
        .chat-send-btn {
            padding: 8px 12px;
            background: var(--accent);
            color: var(--bg-primary);
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-weight: bold;
            font-family: inherit;
            font-size: 9px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .chat-send-btn:hover {
            background: var(--accent-light);
            transform: translateY(-1px);
        }
        
        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 6px;
        }
        
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(0, 217, 255, 0.2);
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 217, 255, 0.4);
        }
        
        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
            }
            .chat-panel {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="grid-overlay"></div>
    
    <div class="container">
        <header class="header">
            <div class="logo">⚡ Quantum Signal</div>
            <div style="display: flex; gap: 15px; flex: 1; margin-left: 20px;">
                <div class="status-indicator">
                    <div class="status-dot"></div>
                    <span>LIVE MONITORING</span>
                </div>
                <div class="time-display" id="timeDisplay">00:00:00 UTC</div>
            </div>
        </header>
        
        <main class="main-content">
            <div class="search-section">
                <div class="search-box">
                    <input type="text" id="symbolInput" placeholder="Search symbol..." maxlength="15">
                    <button class="search-btn" onclick="searchSymbol()">SEARCH</button>
                </div>
            </div>
            
            <div class="symbols-grid" id="symbolsGrid"></div>
            
            <div class="signals-wrapper" id="signalsContainer"></div>
        </main>
        
        <aside class="chat-panel">
            <div class="chat-header">AI Signal Assistant</div>
            <div class="chat-display" id="chatDisplay"></div>
            <div class="chat-input-box">
                <input type="text" id="chatInput" placeholder="Ask about signals..." maxlength="100">
                <button class="chat-send-btn" onclick="sendChat()">SEND</button>
            </div>
        </aside>
    </div>

    <script>
        // ===== ADVANCED SIGNAL ENGINE =====
        class AdvancedSignalEngine {
            constructor() {
                this.symbols = ['BTC/USD', 'ETH/USD', 'SPY', 'AAPL', 'EUR/USD', 'GLD', 'TSLA', 'AMZN', 'XAU/USD', 'OIL/USD', 'EURUSD', 'GBPUSD'];
                this.priceData = new Map();
                this.indicatorCache = new Map();
                this.signals = [];
                this.selectedSignal = null;
                this.chatHistory = [];
                
                this.initializePriceData();
                this.advancedPrompts = this.loadAdvancedPrompts();
            }
            
            initializePriceData() {
                this.symbols.forEach(symbol => {
                    const basePrice = 30000 + Math.random() * 60000;
                    this.priceData.set(symbol, {
                        current: basePrice,
                        history: Array(100).fill(0).map(() => basePrice + (Math.random() - 0.5) * basePrice * 0.05),
                        volume: Math.random() * 1000000,
                        volatility: Math.random() * 50
                    });
                });
            }
            
            loadAdvancedPrompts() {
                return {
                    detail: "Provide comprehensive technical analysis with support/resistance levels, entry/exit strategies, risk assessment, and position sizing recommendations.",
                    risk: "Analyze market risk factors including volatility clustering, tail risk probability, Value-at-Risk (VaR), and optimal stop-loss placement.",
                    momentum: "Evaluate momentum indicators including RSI divergences, MACD histogram acceleration, Stochastic crossovers, and volume confirmation patterns.",
                    trend: "Assess trend strength using moving average confluence, higher-high/lower-low sequences, trendline breaks, and potential reversal signals.",
                    entry: "Generate precise entry signals with execution price, confirmation indicators, optimal entry window, and alternative entries if primary fails.",
                    exit: "Define exit strategy with take-profit levels, trailing stop methodology, breakeven rules, and profit protection mechanisms."
                };
            }
            
            // Multi-timeframe RSI Analysis
            calculateRSI(prices, period = 14) {
                const changes = [];
                for (let i = 1; i < prices.length; i++) {
                    changes.push(prices[i] - prices[i - 1]);
                }
                
                let avgGain = 0, avgLoss = 0;
                for (let i = 0; i < period; i++) {
                    if (changes[i] > 0) avgGain += changes[i];
                    else avgLoss += Math.abs(changes[i]);
                }
                avgGain /= period;
                avgLoss /= period;
                
                let rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                let rsi = 100 - (100 / (1 + rs));
                
                return Math.max(0, Math.min(100, rsi));
            }
            
            // MACD with Signal Line
            calculateMACD(prices, fast = 12, slow = 26, signal = 9) {
                const emaFast = this.calculateEMA(prices, fast);
                const emaSlow = this.calculateEMA(prices, slow);
                const macdLine = emaFast - emaSlow;
                
                const macdHistory = [];
                for (let i = 0; i < prices.length - slow; i++) {
                    const fast = this.calculateEMA(prices.slice(i, i + fast + 1), fast);
                    const slow = this.calculateEMA(prices.slice(i, i + slow + 1), slow);
                    macdHistory.push(fast - slow);
                }
                
                const signalLine = this.calculateEMA(macdHistory, signal);
                const histogram = macdLine - signalLine;
                
                return { macdLine, signalLine, histogram, trend: histogram > 0 ? 'BULLISH' : 'BEARISH' };
            }
            
            calculateEMA(prices, period) {
                const k = 2 / (period + 1);
                let ema = prices[0];
                for (let i = 1; i < Math.min(period * 3, prices.length); i++) {
                    ema = prices[i] * k + ema * (1 - k);
                }
                return ema;
            }
            
            // Bollinger Bands with Standard Deviation
            calculateBollingerBands(prices, period = 20, stdDev = 2) {
                const sma = prices.slice(-period).reduce((a, b) => a + b) / period;
                const variance = prices.slice(-period).reduce((sum, p) => sum + Math.pow(p - sma, 2), 0) / period;
                const std = Math.sqrt(variance);
                
                return {
                    upper: sma + (std * stdDev),
                    middle: sma,
                    lower: sma - (std * stdDev),
                    bandwidth: (2 * std) / sma * 100,
                    position: ((prices[prices.length - 1] - (sma - std)) / (2 * std)) * 100
                };
            }
            
            // Stochastic Oscillator
            calculateStochastic(prices, period = 14, smooth = 3) {
                const high = Math.max(...prices.slice(-period));
                const low = Math.min(...prices.slice(-period));
                const close = prices[prices.length - 1];
                
                let k = high === low ? 50 : ((close - low) / (high - low)) * 100;
                k = Math.max(0, Math.min(100, k));
                
                return { k, d: k, signal: 'NEUTRAL', overbought: k > 80, oversold: k < 20 };
            }
            
            // ATR (Average True Range)
            calculateATR(prices, period = 14) {
                let tr = 0;
                const count = Math.min(period, prices.length - 1);
                
                for (let i = Math.max(1, prices.length - period); i < prices.length; i++) {
                    const high = prices[i];
                    const low = prices[i - 1];
                    tr += Math.abs(high - low);
                }
                
                return tr / count;
            }
            
            // Fibonacci Levels
            calculateFibonacci(prices) {
                const high = Math.max(...prices);
                const low = Math.min(...prices);
                const diff = high - low;
                
                return {
                    r0: high,
                    r236: high - (diff * 0.236),
                    r382: high - (diff * 0.382),
                    r618: high - (diff * 0.618),
                    r786: high - (diff * 0.786),
                    s0: low
                };
            }
            
            // Complex Moving Average Analysis
            calculateMovingAverages(prices) {
                const ma8 = this.calculateEMA(prices, 8);
                const ma20 = this.calculateEMA(prices, 20);
                const ma50 = this.calculateEMA(prices, 50);
                const ma200 = this.calculateEMA(prices, Math.min(200, prices.length));
                
                return {
                    ema8: ma8,
                    ema20: ma20,
                    ema50: ma50,
                    ema200: ma200,
                    alignment: this.checkMAAlignment(ma8, ma20, ma50, ma200)
                };
            }
            
            checkMAAlignment(ma8, ma20, ma50, ma200) {
                if (ma8 > ma20 && ma20 > ma50 && ma50 > ma200) return 'STRONG UPTREND';
                if (ma8 < ma20 && ma20 < ma50 && ma50 < ma200) return 'STRONG DOWNTREND';
                return 'MIXED';
            }
            
            // Advanced Divergence Detection
            detectDivergence(prices, rsi) {
                const recentPrices = prices.slice(-10);
                const recentRSI = Array(10).fill(0).map((_, i) => this.calculateRSI(prices.slice(0, prices.length - 10 + i)));
                
                const priceHigher = recentPrices[9] > recentPrices[0];
                const rsiLower = recentRSI[9] < recentRSI[0];
                
                if (priceHigher && rsiLower) return { type: 'BEARISH', confidence: 'HIGH' };
                if (!priceHigher && !rsiLower) return { type: 'BULLISH', confidence: 'HIGH' };
                
                return { type: 'NONE', confidence: 'LOW' };
            }
            
            // Volume Analysis
            analyzeVolume(symbol) {
                const data = this.priceData.get(symbol);
                return {
                    current: data.volume,
                    trend: Math.random() > 0.5 ? 'INCREASING' : 'DECREASING',
                    strength: Math.random() * 100
                };
            }
            
            // COMPOSITE SIGNAL GENERATION
            generateSignal(symbol) {
                const prices = this.priceData.get(symbol).history;
                const current = prices[prices.length - 1];
                
                // Calculate all indicators
                const rsi = this.calculateRSI(prices);
                const macd = this.calculateMACD(prices);
                const bb = this.calculateBollingerBands(prices);
                const stoch = this.calculateStochastic(prices);
                const atr = this.calculateATR(prices);
                const ma = this.calculateMovingAverages(prices);
                const fib = this.calculateFibonacci(prices);
                const divergence = this.detectDivergence(prices, rsi);
                const volume = this.analyzeVolume(symbol);
                
                // Scoring System
                let buyScore = 0, sellScore = 0, neutralScore = 0;
                
                // RSI Analysis
                if (rsi < 30) { buyScore += 3; }
                else if (rsi > 70) { sellScore += 3; }
                else if (rsi < 50 && rsi > 40) { buyScore += 1; }
                else if (rsi > 50 && rsi < 60) { sellScore += 1; }
                
                // MACD Analysis
                if (macd.histogram > 0 && macd.trend === 'BULLISH') { buyScore += 2.5; }
                else if (macd.histogram < 0 && macd.trend === 'BEARISH') { sellScore += 2.5; }
                
                // Bollinger Bands
                if (current < bb.lower) { buyScore += 2; }
                else if (current > bb.upper) { sellScore += 2; }
                
                // Stochastic
                if (stoch.oversold) { buyScore += 1.5; }
                else if (stoch.overbought) { sellScore += 1.5; }
                
                // Moving Average Alignment
                if (ma.alignment === 'STRONG UPTREND') { buyScore += 3; }
                else if (ma.alignment === 'STRONG DOWNTREND') { sellScore += 3; }
                else if (ma.alignment === 'MIXED') { neutralScore += 2; }
                
                // Divergence
                if (divergence.type === 'BEARISH') { sellScore += 1.5; }
                else if (divergence.type === 'BULLISH') { buyScore += 1.5; }
                
                // Determine Signal Type
                const totalScore = buyScore + sellScore + neutralScore;
                const buyPercent = buyScore / (totalScore || 1);
                const sellPercent = sellScore / (totalScore || 1);
                
                let type = 'NEUTRAL';
                let confidence = 50;
                
                if (buyPercent > 0.55) {
                    type = 'BUY';
                    confidence = Math.min(95, 50 + (buyScore * 5));
                } else if (sellPercent > 0.55) {
                    type = 'SELL';
                    confidence = Math.min(95, 50 + (sellScore * 5));
                } else {
                    type = 'NEUTRAL';
                    confidence = 50 + (neutralScore * 3);
                }
                
                // Calculate levels
                const support = bb.lower;
                const resistance = bb.upper;
                const rr = Math.abs((resistance - current) / (current - support)) || 1;
                
                return {
                    symbol,
                    type,
                    confidence: Math.round(confidence),
                    rsi: Math.round(rsi),
                    macd: macd.histogram > 0 ? '+' : '-',
                    macdValue: Math.round(macd.histogram * 1000) / 1000,
                    price: Math.round(current * 100) / 100,
                    support: Math.round(support * 100) / 100,
                    resistance: Math.round(resistance * 100) / 100,
                    atr: Math.round(atr * 100) / 100,
                    volatility: Math.round(this.priceData.get(symbol).volatility * 10) / 10,
                    volume: volume.trend,
                    rr: Math.round(rr * 10) / 10,
                    ma: ma,
                    bb: bb,
                    timestamp: new Date().toLocaleTimeString('en-US'),
                    indicators: { rsi, macd, bb, stoch, atr, divergence, volume },
                    buyScore: Math.round(buyScore * 10) / 10,
                    sellScore: Math.round(sellScore * 10) / 10
                };
            }
        }
        
        // ===== APPLICATION =====
        const engine = new AdvancedSignalEngine();
        let currentSymbol = 'BTC/USD';
        
        function initializeUI() {
            displaySymbols();
            updateSignals();
            updateClock();
            setInterval(updateClock, 1000);
            setInterval(updateSignals, 1000);
            
            addChatMessage('bot', '⚡ Quantum Signal AI online. Select a symbol or ask me anything about the signals.');
        }
        
        function displaySymbols() {
            const grid = document.getElementById('symbolsGrid');
            grid.innerHTML = engine.symbols.map(s => 
                `<div class="symbol-chip ${s === currentSymbol ? 'active' : ''}" onclick="selectSymbol('${s}')">${s}</div>`
            ).join('');
        }
        
        function selectSymbol(symbol) {
            currentSymbol = symbol;
            displaySymbols();
            updateSignals();
        }
        
        function searchSymbol() {
            const input = document.getElementById('symbolInput');
            const search = input.value.toUpperCase().trim();
            
            if (search && engine.symbols.includes(search)) {
                selectSymbol(search);
                input.value = '';
            }
        }
        
        function updateSignals() {
            const container = document.getElementById('signalsContainer');
            
            engine.signals = [];
            const primary = engine.generateSignal(currentSymbol);
            engine.signals.push(primary);
            
            // Add secondary symbols
            engine.symbols
                .filter(s => s !== currentSymbol)
                .slice(0, 5)
                .forEach(symbol => {
                    engine.signals.push(engine.generateSignal(symbol));
                });
            
            container.innerHTML = engine.signals.map((signal, idx) => `
                <div class="signal-card ${signal.type.toLowerCase()}" onclick="selectSignal(${idx})">
                    <div class="signal-header">
                        <span class="signal-symbol">${signal.symbol}</span>
                        <span class="signal-badge ${signal.type.toLowerCase()}">${signal.type}</span>
                    </div>
                    <div class="signal-metrics">
                        <div class="metric">
                            <div class="metric-label">CONFIDENCE</div>
                            <div class="metric-value">${signal.confidence}%</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">PRICE</div>
                            <div class="metric-value">$${signal.price}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">RSI</div>
                            <div class="metric-value">${signal.rsi}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">VOL</div>
                            <div class="metric-value">${signal.volatility}%</div>
                        </div>
                    </div>
                    <div class="strength-meter">
                        <div class="strength-fill" style="width: ${signal.confidence}%"></div>
                    </div>
                </div>
            `).join('');
        }
        
        function selectSignal(idx) {
            engine.selectedSignal = engine.signals[idx];
            const signal = engine.selectedSignal;
            
            let message = `═══ ${signal.symbol} SIGNAL ANALYSIS ═══\n`;
            message += `Type: ${signal.type} (${signal.confidence}% confidence)\n`;
            message += `Price: $${signal.price} | RSI: ${signal.rsi}\n`;
            message += `Support: $${signal.support} | Resistance: $${signal.resistance}\n`;
            message += `Risk/Reward: 1:${signal.rr} | ATR: ${signal.atr}\n`;
            message += `MACD: ${signal.macd} (${signal.macdValue})\n`;
            message += `Volume Trend: ${signal.volume}`;
            
            addChatMessage('bot', message);
        }
        
        function addChatMessage(sender, text) {
            const display = document.getElementById('chatDisplay');
            const msg = document.createElement('div');
            msg.className = `chat-msg ${sender}`;
            msg.textContent = text;
            display.appendChild(msg);
            display.scrollTop = display.scrollHeight;
        }
        
        function sendChat() {
            const input = document.getElementById('chatInput');
            const text = input.value.trim();
            
            if (!text) return;
            
            addChatMessage('user', text);
            input.value = '';
            
            setTimeout(() => {
                const response = generateAIResponse(text);
                addChatMessage('bot', response);
            }, 200);
        }
        
        function generateAIResponse(query) {
            if (!engine.selectedSignal) {
                return 'Please select a signal first by clicking on any signal card.';
            }
            
            const s = engine.selectedSignal;
            const q = query.toLowerCase();
            
            if (q.includes('detail') || q.includes('full') || q.includes('comprehensive')) {
                return `DETAILED ANALYSIS: ${s.symbol}\n` +
                       `Signal: ${s.type} | Confidence: ${s.confidence}%\n` +
                       `Buy Score: ${s.buyScore}/10 | Sell Score: ${s.sellScore}/10\n` +
                       `RSI: ${s.rsi} (Overbought: >70, Oversold: <30)\n` +
                       `MACD: ${s.macd === '+' ? 'Positive Momentum' : 'Negative Momentum'}\n` +
                       `Price Level: $${s.price}\n` +
                       `Support Cluster: $${s.support}\n` +
                       `Resistance Cluster: $${s.resistance}\n` +
                       `Entry Strategy: ${s.type === 'BUY' ? 'Accumulate on dips to support' : 'Sell rallies to resistance'}\n` +
                       `Stop Loss: ${s.type === 'BUY' ? '$' + Math.round((s.support - s.atr) * 100) / 100 : '$' + Math.round((s.resistance + s.atr) * 100) / 100}`;
            }
            
            if (q.includes('risk') || q.includes('stop') || q.includes('sl')) {
                const sl = s.type === 'BUY' ? Math.round((s.support - s.atr) * 100) / 100 : Math.round((s.resistance + s.atr) * 100) / 100;
                const tp = s.type === 'BUY' ? Math.round((s.resistance + s.atr) * 100) / 100 : Math.round((s.support - s.atr) * 100) / 100;
                
                return `RISK MANAGEMENT: ${s.symbol}\n` +
                       `Entry: $${s.price}\n` +
                       `Stop Loss: $${sl}\n` +
                       `Take Profit: $${tp}\n` +
                       `Risk/Reward: 1:${s.rr}\n` +
                       `Position Size: Calculate based on account risk (2-3% max per trade)\n` +
                       `Max Loss: Risk amount × Account Size\n` +
                       `Profit Target: Risk × ${s.rr}`;
            }
            
            if (q.includes('entry') || q.includes('when') || q.includes('now')) {
                return `ENTRY SIGNAL: ${s.symbol}\n` +
                       `Recommendation: ${s.type === 'BUY' ? '✓ LONG' : '✗ SHORT'}\n` +
                       `Current Price: $${s.price}\n` +
                       `Best Entry: ${s.type === 'BUY' ? `On pullback to $${s.support}` : `On rally to $${s.resistance}`}\n` +
                       `Confirmation: Wait for volume surge\n` +
                       `Timeframe: Day or 4H chart for swing trades\n` +
                       `Alternative Entry: Market order if ${s.type === 'BUY' ? 'price breaks above resistance' : 'price breaks below support'}`;
            }
            
            if (q.includes('technical') || q.includes('indicator')) {
                return `TECHNICAL INDICATORS: ${s.symbol}\n` +
                       `RSI(14): ${s.rsi} - ${s.rsi > 70 ? 'OVERBOUGHT' : s.rsi < 30 ? 'OVERSOLD' : 'NEUTRAL'}\n` +
                       `MACD: ${s.macd === '+' ? 'Bullish Crossover' : 'Bearish Crossover'}\n` +
                       `BB Position: ${Math.round(s.bb.position)}% (0=lower, 100=upper)\n` +
                       `ATR(14): ${s.atr} - Volatility Measure\n` +
                       `MA Trend: ${s.ma.alignment}\n` +
                       `Volume: ${s.volume} with trend strength`;
            }
            
            if (q.includes('support') || q.includes('resistance') || q.includes('level')) {
                return `PRICE LEVELS: ${s.symbol}\n` +
                       `Current: $${s.price}\n` +
                       `Major Support: $${s.support}\n` +
                       `Major Resistance: $${s.resistance}\n` +
                       `Range Width: $${Math.round((s.resistance - s.support) * 100) / 100}\n` +
                       `Breakout Target (Long): $${Math.round((s.resistance + (s.resistance - s.support)) * 100) / 100}\n` +
                       `Breakdown Target (Short): $${Math.round((s.support - (s.resistance - s.support)) * 100) / 100}`;
            }
            
            return `QUICK ANALYSIS: ${s.symbol}\n${s.type} Signal at ${s.confidence}% confidence.\n` +
                   `Price $${s.price} between $${s.support}-$${s.resistance}.\n` +
                   `RSI: ${s.rsi} | MACD: ${s.macd}\n` +
                   `Ask: detail | risk | entry | technical | support`;
        }
        
        function updateClock() {
            const now = new Date();
            const utc = now.toLocaleTimeString('en-US', { timeZone: 'UTC' });
            document.getElementById('timeDisplay').textContent = utc;
        }
        
        // Keyboard handlers
        document.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                if (document.activeElement.id === 'chatInput') sendChat();
                if (document.activeElement.id === 'symbolInput') searchSymbol();
            }
        });
        
        // Initialize
        window.addEventListener('load', initializeUI);
    </script>
</body>
</html>